<style>
  .game-box-row,
  .refer-box-row {
    display: flex;
    justify-content: center;
    flex-wrap: nowrap;
  }

  .game-box-cell,
  .refer-box-cell {
    flex: 1;
    margin: 8rpx;
    max-width: 200rpx;
    border-radius: 15%;
    background-color: #eee;
  }

  .refer-box-cell {
    max-width: 100rpx;
    min-width: 50rpx;
  }

  .game-box-cell:before,
  .refer-box-cell:before {
    display: block;
    content: attr(data-content);
    padding-bottom: 100%;
    height: 0;
    text-align: center;
  }

  .game-box-cell-remove {
    background-color: #f0f0f0 !important;
    box-shadow: inset 0 0 40rpx rgba(0, 0, 0, .2), inset 0 0 25rpx rgba(0, 0, 0, .1);
  }

  .game-box-cell-selected {
    box-shadow: 0 0 12rpx rgba(0, 0, 0, .5);
  }

  .game-box-cell-error {
    box-shadow: 0 0 12rpx #ff685d;
  }
</style>

<template>
  <view class="game-box">
    <view wx:for="{{gameMap}}" wx:for-item="row" wx:for-index="i" class="game-box-row">
      <view wx:for="{{row}}" wx:for-item="cell" wx:key="key" class="game-box-cell {{cell.status !== '' ? 'game-box-cell-' + cell.status : ''}}" @tap="tapCell({{cell}})" style="background-color: {{cell.value}}">
      </view>
    </view>
  </view>

  <scroll-view scroll-x="true">
    <view class="refer-box-row">
      <view wx:for="{{colors}}" class="refer-box-cell" style="background-color: {{item}}">
      </view>
    </view>
  </scroll-view>
</template>

<script>
  import wepy from 'wepy';
  const RGBMaxValue = 255;
  const getRandomNumber = num => Math.floor(Math.random() * num);
  const numberToIntHex = num => {
    let str = Math.floor(num).toString(16);
    if (str.length < 2) {
      str = '0' + str;
    }
    return str.slice(0, 2);
  };
  const colorPointToHex = p => `#${numberToIntHex(p[0])}${numberToIntHex(p[1])}${numberToIntHex(p[2])}`;
  const typeOf = obj => Object.prototype.toString.call(obj).slice(8).slice(0, -1);
  function addVector(v1, v2) {
    return v1.map((item, index) => v1[index] + v2[index]);
  }
  function subtractVector(v1, v2) {
    return v1.map((item, index) => v1[index] - v2[index]);
  }
  function divisionVector(v1, num) {
    return v1.map(item => item / num);
  }
  function generateEndPoint(startPoint, len) {
    const inRange = value => value >= 0 && value <= RGBMaxValue;
    const angle1 = Math.random() * 2 * Math.PI;
    const angle2 = Math.random() * 2 * Math.PI;
    const x = startPoint[0] + len * Math.cos(angle1);
    const _len = len * Math.sin(angle1);
    const y = startPoint[1] + _len * Math.cos(angle2);
    const z = startPoint[2] + _len * Math.sin(angle2);
    return inRange(x) && inRange(y) && inRange(z) ? [x, y, z] : generateEndPoint(startPoint, len);
  }
  function generateColorPoints(count, similar) {
    const startPoint = [getRandomNumber(RGBMaxValue), getRandomNumber(RGBMaxValue), getRandomNumber(RGBMaxValue)];
    const endPoint = generateEndPoint(startPoint, similar);
    const step = divisionVector(subtractVector(endPoint, startPoint), count - 1);
    const points = [startPoint];
    for (let i = 1; i < count; i++) {
      points.unshift(addVector(points[0], step));
    }
    return points;
  }
  export default class GameCell extends wepy.component {
    props = {}
    data = {
      gameMap: [],
      cellData: {},
      colors: [],
      restCouple: 0,
      selectedCellKey: ''
    }
    methods = {
      tapCell (cell) {
        const tapCell = this.gameMap[cell.y][cell.x];
        const selectedCellKey = this.selectedCellKey;
        const selectedCellData = selectedCellKey === '' ? null : this.cellData[this.selectedCellKey];
        const selectedCell = selectedCellKey === '' ? null : this.gameMap[selectedCellData.y][selectedCellData.x];
        if (tapCell.status === 'remove') {
          if (selectedCellKey !== '') {
            // 取消选中
            selectedCell.status = '';
            this.selectedCellKey = '';
          }
        } else if (tapCell.status === 'selected') {
          // 取消当前cell选中
          tapCell.status = '';
          this.selectedCellKey = '';
        } else {
          if (this.selectedCellKey === '') {
            // 选中当前cell
            tapCell.status = 'selected';
            this.selectedCellKey = tapCell.key;
          } else {
            const result = this.matchCouple(tapCell, selectedCell);
            if (result) {
              // 移除cell
              tapCell.status = 'remove';
              selectedCell.status = 'remove';
              this.selectedCellKey = '';
              this.$emit('game.match_couple');
              this.restCouple -= 1;
              if (this.restCouple === 0) {
                this.$emit('game.complete');
              }
            } else {
              // 取消选中
              selectedCell.status = '';
              this.selectedCellKey = '';
              this.$emit('game.match_error');
            }
          }
        }
      }
    }
    onLoad () {
    }
    init (gameConfig) {
      // 数据重置
      this.selectedCellKey = '';
      this.cellData = {};

      // 参数初始化
      this.config = gameConfig;
      this.row = gameConfig.row || 5;
      this.col = gameConfig.col || 4;
      this.similar = gameConfig.similar || 100;

      if ((this.row * this.col) % 2 === 1) throw new Error('不允许奇数个方块！');

      // 生成cell
      if (typeOf(gameConfig.colors) === 'Array' && gameConfig.colors.length > 0) {
        this.colors = gameConfig.colors;
      } else {
        const decimalColors = generateColorPoints(this.row * this.col / 2, this.similar);
        const hexColors = decimalColors.map(item => colorPointToHex(item));
        this.colors = hexColors;
      }
      this.restCouple = this.colors.length;

      // 生成map
      this.gameMap = this.putCellsIntoMap(this.row, this.col, this.colors);

      this.$apply();
      this.$emit('game.start');

      console.log(this.colors);
    }
    matchCouple (tapCell, selectedCell) {
      return tapCell.value === selectedCell.value;
    }
    putCellsIntoMap (row, col, values) {
      const needCount = row * col / 2;
      let cells = [];
      while (cells.length < needCount) {
        cells.push(...values);
      }
      cells = cells.slice(0, needCount);
      cells.push(...cells);

      const map = [];
      for (let i = 0; i < row; i++) {
        const row = [];
        for (let j = 0; j < col; j++) {
          const index = getRandomNumber(cells.length);
          const cellObj = this.generateCellObj(j, i, cells[index]);
          this.cellData[cellObj.key] = cellObj;
          row.push(cellObj);
          cells.splice(index, 1);
        }
        map.push(row);
      }
      return map;
    }
    generateCellObj (x, y, value) {
      const obj = {
        x,
        y,
        key: `${x}.${y}.${value}`,
        value,
        status: ''
      };
      return obj;
    }
  }
</script>

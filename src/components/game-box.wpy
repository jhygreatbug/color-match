<style lang="postcss">
  .game-box-wrap {
    display: flex;
    flex-direction: column;
    height: 100%;
  }

  .game-box {
    position: relative;
    display: flex;
    flex-direction: column;
    justify-content: center;
    flex: auto;
  }

  .game-box-con {
    position: absolute;
    left: 0;
    right: 0;
    margin: 0 auto;
    max-width: 400rpx;
  }

  .refer-box {
    padding: 40rpx 0;
  }

  .game-box-row,
  .refer-box-row {
    display: flex;
    justify-content: center;
    flex-wrap: nowrap;
  }

  .game-box-cell,
  .refer-box-cell {
    box-sizing: border-box;
    margin: 8rpx;
    border-radius: 12%;
    transition: transform 200ms ease;
    transform: scale(1);
  }

  .refer-box-cell {
    flex: 1;
  }
  .refer-box-cell:before {
    display: block;
    content: '';
    padding-bottom: 100%;
    height: 0;
    text-align: center;
  }

  .game-box-cell {
    width: 100rpx;
    height: 100rpx;
  }

  .game-box-col2 .game-box-cell {
    width: 150rpx;
    height: 150rpx;
  }
  .game-box-col3 .game-box-cell {
    width: 120rpx;
    height: 120rpx;
  }

  .refer-box-cell {
    max-width: 90rpx;
    min-width: 50rpx;
  }

  .game-box-cell.active {
    transform: scale(1.1);
  }

  .game-box-cell-remove {
    transform: scale(0);
  }

  .game-box-cell-selected {
    color: rgba(255, 255, 255, .7);
    border: 8rpx solid currentColor;
  }

  .game-box-cell-error:before {
    color: #ff685d;
    border: 8rpx solid currentColor;
  }

</style>

<template>
  <view class="game-box-wrap">
    <view class="game-box">
      <view class="game-box-con">
        <view wx:for="{{gameMap}}" wx:for-item="row" wx:for-index="i" class="game-box-row game-box-col{{colCount}}">
          <view wx:for="{{row}}" wx:for-item="cell" wx:key="key"
            class="game-box-cell {{cell.status !== '' ? 'game-box-cell-' + cell.status : ''}}"
            hover-class="active"
            hover-start-time="0"
            hover-stay-time="0"
            @tap.stop="tapCell({{cell}})"
            style="background-color: {{cell.value}}; color: {{cell.lightBorder}}">
          </view>
        </view>
      </view>
    </view>

    <scroll-view scroll-x="true" class="refer-box">
      <view class="refer-box-row">
        <view wx:for="{{colors}}" class="refer-box-cell" style="background-color: {{item}}">
        </view>
      </view>
    </scroll-view>
  </view>
</template>

<script>
  import wepy from 'wepy';
  import Color from '../lib/Color';
  const RGBMaxValue = 255;
  const typeOf = obj => Object.prototype.toString.call(obj).slice(8).slice(0, -1);
  function inRange(n, a, b) {
    return a <= n && n <= b;
  }
  function randomNum(a, b = 0) {
    return parseInt(Math.random() * (b - a) + a, 10);
  }
  function generateEndPoint(startPoint, len) {
    const angle1 = Math.random() * 2 * Math.PI;
    const angle2 = Math.random() * 2 * Math.PI;
    const x = startPoint[0] + len * Math.cos(angle1);
    const _len = len * Math.sin(angle1);
    const y = startPoint[1] + _len * Math.cos(angle2);
    const z = startPoint[2] + _len * Math.sin(angle2);
    return inRange(x, 0, RGBMaxValue) && inRange(y, 0, 100) && inRange(z, 0, 100) ? [x, y, z] : generateEndPoint(startPoint, len);
  }
  function generateColorPoints(count, similar) {
    const startPoint = [randomNum(RGBMaxValue), randomNum(25, 75), randomNum(25, 75)];
    const endPoint = generateEndPoint(startPoint, similar);
    const colors = Color.interpolation(new Color(startPoint), new Color(endPoint), count);
    return colors.map(item => item.toHexString());
  }
  export default class GameCell extends wepy.component {
    props = {}
    data = {
      gameMap: [],
      cellData: {},
      rowCount: 0,
      colCount: 0,
      colors: [],
      restCouple: 0,
      selectedCellKey: ''
    }
    methods = {
      tapCell (cell) {
        const tapCell = this.gameMap[cell.y][cell.x];
        const selectedCellKey = this.selectedCellKey;
        const selectedCellData = selectedCellKey === '' ? null : this.cellData[this.selectedCellKey];
        const selectedCell = selectedCellKey === '' ? null : this.gameMap[selectedCellData.y][selectedCellData.x];
        if (tapCell.status === 'remove') {
          if (selectedCellKey !== '') {
            // 取消选中
            selectedCell.status = '';
            this.selectedCellKey = '';
          }
        } else if (tapCell.status === 'selected') {
          // 取消当前cell选中
          this.cancelSelectCell(tapCell);
        } else {
          if (this.selectedCellKey === '') {
            // 选中当前cell
            tapCell.status = 'selected';
            this.selectedCellKey = tapCell.key;
          } else {
            const result = this.matchCouple(tapCell, selectedCell);
            if (result) {
              // 移除cell
              tapCell.status = 'remove';
              selectedCell.status = 'remove';
              this.selectedCellKey = '';
              this.$emit('game.match_couple');
              this.restCouple -= 1;
              if (this.restCouple === 0) {
                this.$emit('game.complete');
              }
            } else {
              // 取消选中
              selectedCell.status = '';
              this.selectedCellKey = '';
              this.$emit('game.match_error');
            }
          }
        }
      }
    }
    onLoad () {
    }
    init (gameConfig) {
      // 数据重置
      this.selectedCellKey = '';
      this.cellData = {};

      // 参数初始化
      this.config = gameConfig;
      this.rowCount = gameConfig.row || 5;
      this.colCount = gameConfig.col || 4;
      this.similar = gameConfig.similar || 100;

      if ((this.row * this.col) % 2 === 1) throw new Error('不允许奇数个方块！');

      // 生成cell
      if (typeOf(gameConfig.colors) === 'Array' && gameConfig.colors.length > 0) {
        this.colors = gameConfig.colors;
      } else {
        this.colors = generateColorPoints(this.rowCount * this.colCount / 2, this.similar);
      }
      this.restCouple = this.colors.length;

      // 生成map
      this.gameMap = this.putCellsIntoMap(this.rowCount, this.colCount, this.colors);

      this.$apply();
      this.$emit('game.start');

      console.log(this.colors);
    }
    cancelSelectCell (tapCell) {
      this.selectedCellKey = '';
      if (typeof tapCell === 'object') {
        tapCell.status = '';
      } else {
        this.gameMap.forEach(row => {
          row.forEach(cell => {
            if (cell.status === 'selected') {
              cell.status = '';
              this.$apply();
            }
          });
        });
      }
    }
    matchCouple (tapCell, selectedCell) {
      return tapCell.value === selectedCell.value;
    }
    putCellsIntoMap (row, col, values) {
      const needCount = row * col / 2;
      let cells = [];
      while (cells.length < needCount) {
        cells.push(...values);
      }
      cells = cells.slice(0, needCount);
      cells.push(...cells);

      const map = [];
      for (let i = 0; i < row; i++) {
        const row = [];
        for (let j = 0; j < col; j++) {
          const index = randomNum(cells.length);
          const cellObj = this.generateCellObj(j, i, cells[index]);
          this.cellData[cellObj.key] = cellObj;
          row.push(cellObj);
          cells.splice(index, 1);
        }
        map.push(row);
      }
      return map;
    }
    generateCellObj (x, y, value) {
      const obj = {
        x,
        y,
        key: `${x}.${y}.${value}`,
        value,
        lightBorder: new Color(value).lightness(85, true).saturation(20).toString(),
        status: ''
      };
      return obj;
    }
  }
</script>
